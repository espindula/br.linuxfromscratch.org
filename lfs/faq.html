<!--#set var="pageTitle" value="FAQ do LFS" -->
<!--#include virtual="header.html" -->
<!--#include virtual="menu.html" -->
    <div class="main">
      <h1>Perguntas Frequentes do LFS</h1>

      <p>O FAQ está dividido em três documentos. As <a href="/faq/index.html">Perguntas Frequentes gerais</a> 
      tem links para todas as perguntas e respostas. O <a href="/lfs/faq.html">FAQ do LFS</a> é uma seleção 
      de perguntas frequentes específicas do LFS e o <a href="/blfs/faq.html">FAQ do BLFS</a> é uma seleção 
      de perguntas frequentes específicas do BLFS.</p>

      <a id="lfsfaq"/>
      <h3><a href="#fre">Aprimoramentos solicitados frequentemente</a></h3>
      <ul>
        <li><a href="#why-not-faq">Por que não incluir o FAQ no livro?</a></li>
        <li><a href="#why-vim">Por que o vim está no livro?</a></li>
        <li><a href="#why-not-package-management">Por que não existe nenhum gerenciador de pacotes no livro?</a></li>
        <li><a href="#no-poweroff">Como faço minha máquina desligar no término das atividades?</a></li>
        <li><a href="#uefi">Como inicializo o LFS com UEFI?</a></li>
        <li><a href="#rebuild-ch8">Posso ignorar um pacote do Capítulo 8, vez que ele já foi construído no 
        Capítulo 6 ou 7 e está funcionando corretamente?</a></li>
        <li><a href="#get-rid-of-lib64">Posso modificar o código da GCC e me livrar do /lib64?</a></li>
      </ul>
      <h3><a href="#resources">Ao ler e construir o LFS</a></h3>
      <ul>
        <li><a href="#what-dist">Qual distribuição eu deveria usar para começar?</a></li>
        <li><a href="#kernel-modules">Como eu compilo um núcleo ou configuro módulos?</a></li>
        <li><a href="#gcc-warnings">Os avisos do compilador oriundos da GCC são ruins?</a></li>
        <li><a href="#dirty-sources">Preciso manter o fonte depois da instalação?</a></li>
        <li><a href="#procs-lfs">Existem informações acerca de como construir o LFS em outros processadores?</a></li>
        <li><a href="#cross-compile">Como eu compilo cruzadamente o LFS?</a></li>
        <li><a href="#dos-text">O que é um arquivo de texto no formato DOS?</a></li>
        <li><a href="#wget">Existe uma maneira de baixar todos os arquivos atuais de uma vez?</a></li>
      </ul>
      <h3><a href="#generrors">Erros gerais de compilação</a></h3>
      <ul>
        <li><a href="#optimizations">Quando usar sinalizadores de otimização (configurando a CFLAGS)</a></li>
	<li><a href="#configure-errors">A saída gerada do configure mostra erros; "gcc -V" não está errado?</a></li>
        <li><a href="#config-ice">Por que o GCC informa "Erro interno do compilador" para um programa "olá mundo"?</a></li>
        <li><a href="#dirty-sources">Eu não excluí a árvore do fonte depois da minha tentativa mais recente. Eu preciso?</a></li>
        <li><a href="#perm-denied">Eu estou obtendo `/dev/null: Permissão negada'</a></li>
        <li><a href="#sig11">sinal 11 (erro interno: Falha de segmentação)</a></li>
        <li><a href="#chroot-no-such-file">“Esse arquivo ou diretório não existe” tentando fazer chroot</a></li>
        <li><a href="#configure-no-such-file">bash: ./configure: Esse arquivo ou diretório não existe</a></li>
        <li><a href="#bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</a></li>
        <li><a href="#conf-guess-fail">configure não consegue adivinhar meu tipo de dispositivo.</a></li>
        <li><a href="#config-not-gnu-c">verificando se estamos usando GNU C... não</a></li>
        <li><a href="#no-ptys">O sistema não tem mais ptys. Peça para o(a) administrador(a) do sistema criar mais.</a></li>
        <li><a href="#config-status-0ax-y">./config.status: line 508: 0a1,66: comando não encontrado (ou 
        qualquer mensagem semelhante com apenas números diferentes)</a></li>
        <li><a href="#dev-null-as-cache">"configure: carregando cache /dev/null" em config.log</a></li>
      </ul>
      <h3><a href="#packerrors">Erros específicos de pacote</a></h3>
      <ul>
        <li><a href="#m4-mb-len-max-wrong">M4: Valor assumido de MB_LEN_MAX errado</a></li>
        <li><a href="#systemd-user-credentials-esrch">Systemd: systemd-networkd.service: Falha ao determinar 
        as credenciais de usuário(a): esse processo não existe</a></li>
      </ul>
      <h3><a href="#confboot">Problemas de configuração e inicialização</a></h3>
      <ul>
        <li><a href="#unable-to-mount-root">Pânico de núcleo - não sincronizando: VFS: Não é possível montar o root fs em ...</a></li>
        <li><a href="#respawning-too-fast">init: Id &quot;1&quot; regerando muito rápido: desativado por 5 minutos</a></li>
        <li><a href="#eth0-unknown-interface">eth0:interface desconhecida</a></li>
        <li><a href="#irq-nobody-cared">IRQ 9: ninguém se importou (tente inicializar com a opção "irqpoll")</a></li>
        <li><a href="#lfs-very-slow">O sistema LFS está muito mais lento que a distribuição anfitriã (ou outra distribuição)</a></li>
      </ul>
      <div class="newsItem"></div>

      <h3 id="fre">Aprimoramentos solicitados frequentemente</h3>
      <dl>
        <dt id="why-not-faq">Por que não incluir o FAQ no livro?</dt>
        <dd>

          <p>Marc Heerdink possivelmente tenha dito isso melhor em uma postagem na lfs-dev:</p>

          <blockquote><p>O problema é que o FAQ é um documento dinâmico. O FAQ para um lançamento de livro é 
          lançado somente depois da versão do livro em si, porque o FAQ é atualizado para refletir as 
          perguntas feitas acerca da versão atual do livro. Um link é melhor, pois você sempre terá as 
          respostas mais atualizadas à mão.</p></blockquote>

        </dd>
        <dt id="why-vim">Por que o vim está no livro?</dt>
        <dd>

          <p>Isso está bastante bem discutido no tópico que começa
<a href = "https://lists.linuxfromscratch.org/sympa/arc/lfs-dev/2002-02/msg00019.html">nesta postagem</a>.</p>

        </dd>
        <dt id="why-not-package-management">Por que não existe nenhum gerenciador de pacotes no livro?</dt>
        <dd>

          <p>O gerenciamento de pacotes – além daquele fornecido por tarballs e makefiles – está além do 
          escopo do livro. Se nada mais acontecer, o número de "soluções" diferentes deveria sugerir alguns 
          dos motivos.</p>

          <p>Aqui estão algumas das opções:</p>
          <ul>

            <li>Nenhum gerenciamento de pacotes é realmente necessário. A menos que seja desejável monitorar 
            minuciosamente o posicionamento do arquivo do pacote, qualquer pacote grande o suficiente para 
            garantir a remoção por motivos de espaço em disco pode ser instalado em /opt, conforme detalhado 
            pelo FHS (talvez em /opt/foo-x.x com um link a partir de /opt/foo), e novos lançamentos 
            geralmente podem ser instalados sobre as antigos, embora as principais atualizações e bibliotecas 
            geralmente sejam melhor feitas reconstruindo-se o sistema de baixo para cima.</li>

            <li>RPM, o Redhat Package Manager, é usado por diversas distribuições. Ele está disponível a 
            partir de <a href = "https://rpm.org/">https://rpm.org/</a> e existe uma
<a href = "../hints/downloads/files/">Dica do RPM</a> para ajudar com a instalação.</li>

            <li>Existem várias implementações de gerenciamento de pacotes no estilo de link simbólico:
            <ul>
              <li>Graft está disponível a partir de
<a href = "https://peters.gormand.com.au/Home/tools">https://peters.gormand.com.au/Home/tools</a>.</li>
              <li>GNU Stow está disponível a partir de
<a href = "https://www.gnu.org/software/stow/">https://www.gnu.org/software/stow/</a>.</li>
            </ul>
            </li>

            <li>O gerenciador de pacotes do NetBSD, pkgsrc, está disponível em outros sistemas, incluindo 
            Linux. Ele está em
<a href="ftp://ftp.netbsd.org/pub/pkgsrc/stable/">ftp://ftp.netbsd.org/pub/pkgsrc/stable/</a>.</li>

            <li>Originalmente baseado em um script escrito pelo próprio Gerard Beekmans do LFS, install-log 
            registra uma lista de arquivos instalados por um pacote à medida que o pacote é instalado. Ele 
            está disponível a partir de
<a href="https://install-log.sourceforge.net/">https://install-log.sourceforge.net/</a>.</li>

            <li>CheckInstall tenta registrar chamadas de sistema feitas por "make install". Ele está 
            disponível a partir de
<a href="https://asic-linux.com.mx/%7Eizto/checkinstall/">https://asic-linux.com.mx/~izto/checkinstall/</a>.</li>

            <li>pkgutils, usado pela distribuição CRUX, está disponível a partir de
<a href="https://crux.nu/Wiki/FaqPkgUtils">https://crux.nu/Wiki/FaqPkgUtils</a>.</li>

            <li>Existem algumas <a href="../hints/downloads/files/">dicas</a> disponíveis para gerenciadores 
            de pacotes.</li>

          </ul>

          <p>Se você tiver uma adição para a lista, por favor, envie uma mensagem eletrônica com o id dela, 
          URL e outras informações para o(a) mantenedor(a) do FAQ ou para uma lista de discussão apropriada 
          do LFS, de forma que ela possa ser adicionada aqui.</p>

        </dd>
        <dt id="no-poweroff">Como faço minha máquina desligar no término das atividades?</dt>
        <dd>

          <p>Gerenciamento de Eletricidade é uma função do núcleo; você precisa habilitá-lo no núcleo. No 
          núcleo 5.11, você tem de habilitar as opções para <code>ACPI (Advanced Configuration and Power 
          Interface</code> sob <code>Power managerment and ACPI options</code>. Para máquinas x86 de 32 bits 
          muito antigas, você provavelmente irá querer as opções de APM; máquinas mais novas geralmente 
          exigem ACPI. Certifique-se de que ou APM ou ACPI esteja habilitado no núcleo, mas, definitivamente 
          <strong>não</strong> ambos ao mesmo tempo - isso tem sido conhecido por causar problemas, tais como 
          nenhum dos dois realmente tendo efeito. Tente também desabilitar o SMP se você tiver somente um 
          processador; ele também impede um desligamento adequado. Certifique-se de ler a ajuda de cada 
          opção.</p>

          <p>Depois de reinicializar no novo núcleo, você deveria estar apto(a) a desligar tua máquina com o 
          comando <code>shutdown -h now</code> ou <code>poweroff</code> (leia-se também <code>man 
          shutdown</code> e <code>man halt</code>). Se você compilou APM ou ACPI como módulos, certifique-se 
          de que eles estejam carregados antes de tentar desligar. Algumas máquinas exigem que o APM ou ACPI 
          seja compilado no núcleo, porque ele [o APM ou o ACPI] precisa ser inicializado durante a 
          inicialização.</p>

        </dd>

        <dt id="uefi">Como inicializo o LFS com UEFI?</dt>
        <dd>

          <p>O GRUB pode ser construído para UEFI, mas fazer isso precisa de vários pacotes além do escopo do 
          LFS. Você pode consultar <a href="/blfs/view/svn/postlfs/grub-efi.html">a página do BLFS para 
          isso</a>.</p>

        </dd>

        <dt id="rebuild-ch8">Posso ignorar um pacote do Capítulo 8, vez que ele já foi construído no Capítulo 6 ou 7 e está funcionando corretamente?</dt>
        <dd>
          <p>Resposta curta: não.</p>
 
          <p>Resposta longa: queremos que o LFS seja "estabelecido": se algum pacote for reconstruído no 
          sistema LFS, o resultado (bibliotecas e binários) deveria ser o mesmo que o resultado no final do 
          livro do LFS. No Capítulo 6 as ferramentas são compiladas cruzadamente, onde muitos testes no 
          script <code>configure</code> não conseguem ser feitos. O resultado "adivinhado" será usado, 
          soluções alternativas desnecessárias serão habilitadas ou recursos opcionais serão desabilitados. 
          As ferramentas no Capítulo 7 são construídas para resolver dependências circulares: muitos dos 
          recursos opcionais delas dependem de pacotes ainda não construídos e tem de ser desabilitados. 
          Portanto, reconstruí-las no Capítulo 8 é necessário.</p>

          <p>Por outro lado, se você estiver construindo o Linux para alguma plataforma realmente pequena 
          onde você não consegue construir pacotes em um tempo razoável (por exemplo, um ARM de 16 MHz), você 
          pode compilar cruzadamente tudo no Capítulo 6, já que os Capítulos 7 e 8 não são aplicáveis. Ou 
          você pode fazer os Capítulos 7 e 8 com um emulador como o
<a href="/blfs/view/stable/postlfs/qemu.html">QEMU</a>.</p>

        </dd>
        <dt id="get-rid-of-lib64">Posso modificar o código da GCC e me livrar do /lib64?</dt>
        <dd>
          <p>Resposta curta: não.</p>
 
          <p>Resposta longa: o LSB impõe que o carregador de ELF esteja em /lib64/ld-linux-x86-64.so.2 no 
          x86-64.</p>

          <p>Resposta ainda mais longa: quando o núcleo é instruído a executar um executável ELF vinculado 
          dinamicamente, ele lê o caminho para o carregador de ELF rigidamente codificado no executável ELF, 
          que é /lib64/ld-linux-x86-64.so.2. Portanto, se não existir, o LFS não será capaz de executar 
          nenhum executável vinculado dinamicamente compilado em outro lugar. Por exemplo, executáveis 
          procedentes de pacotes de software comerciais (MATLAB ou COMSOL) ou binários baixados a partir da 
          página de lançamento do GitHub não executarão.</p>

        </dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="resources">Ao ler e construir o LFS</h3>
      <dl>
        <dt id="what-dist">Qual distribuição eu deveria usar para começar?</dt>
        <dd>

          <p>A maioria das distribuições relativamente recentes deveria servir. Você poderia consultar
<a href="/lfs/view/stable/chapter02/hostreqs.html">a página Requisitos do Sistema Anfitrião</a>.</p>

          <p>Certifique-se de ter instalado e (ou) atualizado os pacotes de desenvolvimento. (Procure aqueles 
          que começam com "gcc", "glibc" ou "libstdc++" ou terminam com "-dev" ou "-devel").</p>

          <p>Se você quiser usar o LFS como teu sistema principal e deseja instalá-lo sem primeiro instalar 
          uma distribuição, também é possível usar uma imagem ao vivo em DVD ou pendrive. Todas as principais 
          distribuições fornecem uma.</p>

        </dd>
        <dt id="kernel-modules">Como eu compilo um núcleo ou configuro módulos?</dt>
        <dd>

          <p>Em /usr/share/doc/linux-x.y.z ou onde quer que você desempacotou teu fonte do núcleo e a ajuda 
          na ferramenta de configuração do núcleo (make menuconfig), veja-se o Module-HOWTO em
<a href="https://www.tldp.org/HOWTO/Module-HOWTO/">https://www.tldp.org/HOWTO/Module-HOWTO/</a>.</p>

        </dd>
        <dt id="gcc-warnings">Os avisos do compilador oriundos da GCC são ruins?</dt>
        <dd>
          <p>Resposta curta: não.</p>

          <p>Resposta longa: provavelmente, mas somente para alguém que trabalha no pacote que você está 
          tentando compilar. Na maioria das vezes, tudo ficará bem, a menos que o make termine com um 
          erro.</p>

          <p>Aqui está um exemplo:</p>
          <div class="cmd">
            <p>sk ~/tmp $ cat &gt; Makefile<br />
               main:<br />
               gcc main.c<br />
               sk ~/tmp $ cat &gt; main.c<br />
               void main() { exit(0); }<br />
               sk ~/tmp $ make<br />
               gcc main.c<br />
               <strong>main.c: Na função `main':</strong><br />
               <strong>main.c:1: aviso: o tipo de retorno de `main' não é `int'</strong><br />
               sk ~/tmp $ ######## isso funcionou ########<br />
               sk ~/tmp $<br />
               sk ~/tmp $ cat &gt; main.c<br />
               int main() { e<span class="strong">xx</span>it(0) }<br />
               sk ~/tmp $ make<br />
               gcc main.c<br />
               <strong>main.c: Na função `main':</strong><br />
               <strong>main.c:1: erro de análise antes de `}'</strong><br />
               <strong>make: *** [main] Erro 1</strong><br />
               sk ~/tmp $ ######## isso falhou ########<br />
               sk ~/tmp $</p>
          </div>

          <p>Se você puder determinar que algum aviso indica um defeito real no software, informe o(a) 
          mantenedor(a) do mesmo.</p>

        </dd>

        <dt id="procs-lfs">Existem informações acerca de como construir o LFS em outros processadores?</dt>
        <dd>

          <p>Para informações acerca de como construir o LFS para uma ampla variedade de sistemas, dê uma 
          olhada na <a href="https://trac.clfs.org/wiki/read">ramificação Cross-LFS</a> do LFS.</p>

          <p>Para ARM, consulte a bifurcação do LFS para ARM (64 bits ou 32 bits) (
<a href='https://clfs.org/~kb0iic/lfs-sysv'>SysV</a> e
<a href='https://clfs.org/~kb0iic/lfs-systemd'>Systemd</a>), mantido por William Harrington; e outra 
          ramificação ARM64 do LFS (somente 64 bits,
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/arm64-systemd/'>Systemd</a> e
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/arm64/'>SysV [NÃO TESTADO!]</a>), mantida 
          por Xi Ruoyao.</p>

        </dd>
        <dt id="cross-compile">Como eu compilo cruzadamente o LFS?</dt>
        <dd>

          <p>Frequentemente é útil compilar o LFS para uma máquina em outra máquina. Digamos usar aquele 
          Athlon rápido de 1 Ghz para construir uma instalação para um 486 antigo. Embora isso tecnicamente 
          não seja compilação cruzada, os binários compilados para o Athlon não podem ser executados no 486 
          porque os binários compilados para o processador mais recente usam recursos que o processador mais 
          antigo não tem.</p>

          <p>O livro LFS especificamente para compilação cruzada é o livro
<a href="https://trac.clfs.org/wiki/read">Cross-LFS</a>. Outra fonte de informações seria a
<a href="/hints/downloads/files/">dica de compilação cruzada</a>.</p>

          <p>Os recursos fornecidos acima estão bastante desatualizados. Você pode modificar o processo de 
          construção do LFS depois do LFS 10.0 (desenvolvido por Pierre Labastie) para compilação cruzada do 
          LFS: configure <span>$LFS_TGT</span> para o trio de tua plataforma alvo e construa o conjunto de 
          ferramentas cruzadas no Capítulo 5 e ferramentas temporárias no Capítulo 6 normalmente. No final do 
          Capítulo 6, construa um núcleo e um carregador de inicialização para o alvo. Em seguida, copie o 
          sistema temporário para a plataforma alvo, inicialize-o e continue a construção a partir do 
          Capítulo 7. Leia-se a ramificação clfs-ng (
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/clfs-ng/'>SysV</a> e
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/clfs-ng-systemd/'>Systemd</a>) para 
          detalhes.</p>

        </dd>
        <dt id="dos-text">O que é um arquivo de texto no formato DOS?</dt>
        <dd>
          <p>Tem a ver com os caracteres usados ​​para finalizar as linhas.</p>
          <p>Existem dois que podem ser usados:</p>
          <ul>

            <li>Alimentação de linha: (LF) Octal:012 Decimal:10 Hexadecimal:0A Escape no estilo C:'\n' Desce 
            uma linha.</li>

            <li>Retorno de carro: (CR) Octal:015 Decimal:13 Hexadecimal:0D Escape no estilo C:'\r' Move para 
            a margem esquerda.</li>

          </ul>

          <p>Unix, DOS e MacOS usam, cada um, uma combinação diferente para finalizar linhas em arquivos de 
          texto:</p>

          <ul>

            <li>Unix: apenas LF. É por isso que, quando um arquivo de texto no formato Unix é enviado para 
            uma impressora raw, ela imprime<br />

                &nbsp;&nbsp;como<br />
                &nbsp;&nbsp;&nbsp;&nbsp;degraus de<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;escadas.<br /></li>

            <li>DOS: ambos, CRLF. É por isso que se você fizer "cat -v" em um arquivo DOS, verá um "^M" 
            (control m é retorno de carro) no final de cada linha. E é por isso que os scripts não funcionam 
            quando escritos com o Microsoft Notepad. O núcleo procura por "/bin/sh^M" que não existe. Existe 
            um "/bin/sh", mas nada com um "^M" anexado.</li>

            <li>MacOS clássico (antes do Mac OS X): somente CR. As impressoras provavelmente imprimem cada 
            linha acima da primeira, e as ferramentas Unix pensam que o arquivo inteiro é uma linha com "^M" 
            por toda parte. O Mac OS X segue a convenção Unix (somente LF).</li>

          </ul>
          <p>Para mudar de DOS para Unix, use</p>
          <div class="cmd">
            <p>cp &lt;idarquivo&gt; &lt;idarquivo&gt;.dos &amp;&amp;<br />
               cat &lt;idarquivo&gt;.dos | tr -d '\r' &gt; &lt;idarquivo&gt;</p>
          </div>

          <p>Ou no <code>vim</code>, você consegue converter um arquivo com <code>:set ff={unix, dos, 
          mac}</code>. Outras conversões provavelmente exigirão sed ou um uso diferente de tr e serão 
          deixadas como exercício para o(a) leitor(a).</p>

        </dd>
        <dt id="wget">Existe uma maneira de baixar todos os arquivos atuais de uma vez?</dt>
        <dd>

          <p>Sim. Você consegue baixar o arquivo LFS-BOOK-x.y-wget-list
<a href="https://www.linuxfromscratch.org/lfs/downloads/stable/wget-list">https://www.linuxfromscratch.org/lfs/downloads/stable/wget-list</a>. 
          Para baixar todos os arquivos, use a versão do <code>wget</code> na tua distribuição anfitriã para 
          executar:</p>

          <code>wget --input-file=LFS-BOOK-x.y-wget-list</code>

        </dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="generrors">Erros gerais de compilação</h3>
      <dl>
        <dt id="optimizations">Quando usar sinalizadores de otimização (configurando a CFLAGS)</dt>
        <dd>

          <p>Se você estiver recebendo erros e estiver configurando CFLAGS ou, do contrário, passando 
          sinalizadores de otimização para o compilador, esse possivelmente seja o problema.</p>

          <p>Se você perguntar na lista e eles(as) não conseguirem descobrir imediatamente, provavelmente 
          sugerirão tentar sem otimização. Portanto, se você apenas tentar novamente sem antes perguntar, 
          estará um passo à frente deles(as) :)</p>

          <p>Digno de observação é que a otimização de binutils, gcc ou glibc possivelmente faça com que 
          qualquer outro pacote falhe para compilar ou executar ou, do contrário, se comporte mal de maneiras 
          estranhas e misteriosas. Além disso, a otimização que funciona para outra pessoa possivelmente não 
          funcione para você. Sinalizadores que costumavam funcionar possivelmente parem de funcionar 
          misteriosamente. Mesmo algumas pequenas mudanças inocentes no hardware podem fazer a diferença.</p>

          <p>(Se você não sabe o que são sinalizadores de otimização, não se preocupe, você realmente não 
          precisa).</p>

        </dd>
	<dt id="configure-errors">A saída gerada do configure mostra erros; "gcc -V" não está errado?</dt>
        <dd>

	  <p>Para determinar o que está presente no sistema, os scripts de configuração tentam vários 
	  comandos com várias opções de linha de comando. Eles então executam ações dependendo do código de 
	  saída dos comandos. Alguns desses comandos podem escrever mensagens de erro, e é isso que você vê, 
	  por exemplo, com "gcc -V". Mas o script de configuração em si não falhou.</p>

        </dd>
        <dt id="config-ice">Por que o GCC informa "Erro interno do compilador" para um programa "olá mundo"?</dt>
        <dd>
          <p>Você superotimizou o gcc.</p>
        </dd>
        <dt id="dirty-sources">Eu não excluí a árvore do fonte depois da minha tentativa mais recente. Eu preciso?</dt>
        <dd>

          <p>Sim. Em geral, <code>make clean</code> ou <code>make dist-clean</code> não são confiáveis ​​para 
          fontes limpos. Especialmente quando você hackeou manualmente os fontes ou aplicou remendos, você 
          deveria primeiro tentar novamente com um novo pacote desempacotado. A única exceção a essa regra é 
          o núcleo Linux, que exige que os fontes dele estejam presentes quando módulos de terceiros(as), 
          como os controladores NVidia, são necessários.</p>

        </dd>
        <dt id="perm-denied">Eu estou obtendo `/dev/null: Permissão negada'</dt>
        <dd>
          <p>/dev/null se parece com isto:</p>
          <div class="cmd">
            <p>$ ls -l /dev/null<br />
               crw-rw-rw- 1 root root 1, 3 Aug  3  2000 /dev/null</p>
          </div>

          <p>Se não, deveria. Consulte-se
<a href="#dev-null-as-cache">"configure: loading cache /dev/null" no config.log</a>.

          <p>Se parecer certo, o problema provavelmente está nas tuas opções de montagem. Veja-se a resposta 
          para
"<a href="#bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</a>", acima.</p>

        </dd>
        <dt id="sig11">sinal 11 (erro interno: Falha de segmentação)</dt>
        <dd>

          <p>A resposta longa está em
<a href="https://www.bitwizard.nl/sig11/">https://www.bitwizard.nl/sig11/</a>.</p>

          <p>A resposta curta é que se a reiniciação do make for um pouco mais longe a cada vez, você tem um 
          problema de hardware. (Se o make, ou o que quer que você esteja executando, falhar sempre no mesmo 
          lugar, então não é hardware).</p>

          <p>Primeiro, não faça overclock demais da CPU. Observe que, com uma CPU Intel "K" (desbloqueada), 
          mesmo a configuração padrão da placa-mãe geralmente já está em overclock, de forma que você 
          possivelmente precise até mesmo <b>retroceder</b> a partir do padrão, especialmente quando a CPU 
          está abaixo da média: a diferença individual entre todas as CPUs de um mesmo modelo pode ter um 
          efeito significativo na capacidade de overclock, portanto, comprar uma CPU desbloqueada é uma 
          espécie de jogo.</p>

          <p>Supondo que você não esteja fazendo overclock, o problema de hardware mais provável é memória 
          ruim, que você consegue verificar com Memtest86+ oriundo de
<a href="https://www.memtest.org/">https://www.memtest.org/</a>. <p>O superaquecimento da CPU é outro 
          problema comum de hardware. Certifique-se de que o cooler esteja instalado corretamente com pasta 
          térmica aplicada. E alguns coolers (especialmente coolers líquidos multifuncionais) não podem ser 
          configurados via BIOS e precisam de controlador de núcleo e (ou) software especial (por exemplo,
<a href='https://github.com/liquidctl/liquidctl'>liquidctl</a>) para configurar os parâmetros 
          corretamente. Se esse cooler não estiver configurado corretamente, ele poderá funcionar em uma 
          velocidade mais baixa (ou nem funcionar). Se o cooler já estiver funcionando em velocidade máxima, 
          mas a CPU ainda superaquecer, atualize o cooler ou faça downclock da CPU via BIOS.</p>

          <p>Se a memória ruim e o superaquecimento da CPU puderem ser descartados, veja-se a resposta 
          longa.</p>

        </dd>
        <dt id="chroot-no-such-file">“Esse arquivo ou diretório não existe” tentando fazer chroot</dt>
        <dd>
          <p>Exemplo desse erro é:</p>
          <div class="cmd">
            <p>/usr/bin/env: /bin/bash: No such file or directory</p>
          </div>

          <p>Se você tem certeza de que $LFS/bin/bash existe, o que acontece provavelmente é que o caminho 
          para o caminho do vinculador dinâmico incorporado no executável seja /lib64/ld-linux-x86-64.so.2 
          (/lib/ld-linux.so.2 para 32 bits), e quando alguém vai executar o binário dentro do chroot onde 
          /lib64/ld-linux-x86-64.so.2 ainda não existe, a mensagem de erro muito inútil
<code>No such file or directory</code> é exibida.</p>

          <p>Verifique se o link simbólico $LFS/lib64/ld-linux-x86-64.so.2 (deve ter como alvo 
          ../lib/ld-linux-x86-64.so.2 ou ../lib/ld-linux.so.2 para 32 bits) e (ou) $LFS/lib (deveria ter como 
          alvo usr/lib) estão quebrados. Observe que esses links simbólicos precisam ser relativos (ou seja, 
          deveriam ser ../lib/ld-linux-x86-64.so.2, <b>não</b> $LFS/lib/ld-linux-x86-64-so.2), de forma que 
          eles ainda sejam válidos no ambiente chroot.</p>

        </dd>
        <dt id="configure-no-such-file">bash: ./configure: Esse arquivo ou diretório não existe</dt>
        <dd>

          <p>Você se esqueceu de mudar de diretório (<code>cd</code>) para dentro do diretório extraído do 
          pacote depois de extraí-lo.</p>

        </dd>
        <dt id="bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</dt>
        <dd>

          <p>Você provavelmente está recebendo isso enquanto constrói binutils no Capítulo 5 do Livro LFS. O 
          problema provavelmente está nas tuas opções de montagem. Você provavelmente tem uma linha no 
          /etc/fstab como:</p>

          <code>/dev/sda10  /mnt/lfs  ext2  user  1  2</code>

          <p>'user' é o sinalizador de montagem e é o problema. Para citar a página de manual do mount:</p>

          <cite>user: Permitir que um(a) usuário(a) comum monte o sistema de arquivos. Essa opção implica as 
          opções noexec, nosuid e nodev (a menos que substituídas por opções subsequentes, como na linha de 
          opções user,exec,dev,suid).</cite>

          <p>Portanto, mude a linha no /etc/fstab como isto:</p>

          <code>/dev/sda10  /mnt/lfs  ext2  defaults  1  2</code>

        </dd>
        <dt id="conf-guess-fail">configure não consegue adivinhar meu tipo de dispositivo.</dt>
        <dd>
          <p>Sintomas típicos se parecem com isto:</p>
          <div class="cmd">
            <p>sk ~/tmp-0.0 $ ./configure<br />
               creating cache ./config.cache<br />
               checking host system type...<br />
               <strong>configure: error: can not guess host type; you must specify one</strong><br />
               sk ~/tmp-0.0 $</p>
          </div>

          <p>O problema geralmente é que o conjunto de comandos sequenciais não consegue executar o 
          compilador. Geralmente é apenas um link simbólico /usr/bin/cc ausente. Você consegue consertar isso 
          assim:</p>

          <code>cd /usr/bin &amp;&amp; ln -s gcc cc</code>

          <p>Se isso não funcionar, verifique o arquivo config.log criado pelo configure. Os erros são 
          registrados lá e possivelmente indiquem o problema.</p>

        </dd>
        <dt id="config-not-gnu-c">verificando se estamos usando GNU C... não</dt>
        <dd>
          <p>Se você estiver recebendo um erro oriundo do configure como:</p>
          <div class="cmd">
            <p>verificando se estamos usando GNU C... não<br />
               configure: erro: GNU libc precisa ser compilada usando GNU CC</p>
          </div>

          <p>Pode ser porque o grep não está funcionando. Para testar se o grep está funcionando no ambiente 
          chroot, execute o seguinte comando a partir <em>de dentro</em> do chroot:</p>

          <code>grep -E root /etc/passwd</code>

          <p>Se não imprimir a linha do root a partir do /etc/passwd, novamente, você tem um problema. (Esse 
          teste também funciona se você encontrar o problema depois de reinicializar no novo sistema 
          LFS).</p>

        </dd>
        <dt id="no-ptys">O sistema não tem mais ptys. Peça para o(a) administrador(a) do sistema criar mais.</dt>
        <dd>

          <p>Se isso acontecer no ambiente chroot do LFS, certifique-se de que teu núcleo do anfitrião 
          suporta o pseudo terminal UNIX 98 (todas as distribuições de área de trabalho ou servidores não tão 
          antigas deveriam suportá-lo) e que os sistemas de arquivos virtuais do núcleo tenham sido montados 
          corretamente antes de entrar no ambiente chroot.</p>

          <p>If it happens in the complete system built following the SysV
          revision of the LFS book, it's likely you've missed the line for
          the <code>devpts</code> filesystem in <code>/etc/fstab</code>.

        </dd>
        <dt id="config-status-0ax-y">./config.status: line 508: 0a1,66: command not found (or any similar message with only numbers different)<dt>
        <dd>
          <p>Check if <code>config.log</code> contains "configure: loading
          cache /dev/null".  If it's the case, refer to
          <a href='#dev-null-as-cache'>the entry for it</a>.
        </dd>
        <dt id="dev-null-as-cache">"configure: loading cache /dev/null" in
        config.log</dt>
        <dd>
          <p>If it happens in the LFS chroot environment, it's likely you've
          forgotten to bind mount <code>/dev</code> to <code>$LFS/dev</code> in
          "Preparing Virtual Kernel File Systems".</p>
          <p>Exit from the chroot environment first.  Then run
          <code>ls -l /dev/null</code>.  It should output something like
          <code>crw-rw-rw- 1 root root 1, 3 {some date} /dev/null</code>.
          Especially, the first letter <code>c</code> and the numbers
          <code>1, 3</code> must be correct.
          If not, it means your host distro is somehow broken (it may happen
          if you used the dangerous <code>rm -rf $LFS/*</code> command or
          similar when <code>/dev</code> had been bind mounted).  For a modern host
          distro it can be fixed by rebooting (a broken <code>/dev</code> may
          prevent normal rebooting and you may need to use the reset button).
          For a very old host distro, you may need to reinstall it (so why not
          update to a modern one? :)</p>
          <p>Now we've known the host distro is sane.  Make sure
          <code>$LFS</code> is correctly set and the LFS partition is mounted
          first.  Use <code>umount -R $LFS/dev</code> to unmount
          <code>$LFS/dev</code> (in case you've mounted something wrong there),
          then remove everything in <code>$LFS/dev</code> and follow the
          "Preparing Virtual Kernel File Systems" section to mount
          <code>$LFS/dev</code> and <code>$LFS/dev/pts</code> correctly.  Once
          they are mounted, you can reenter the chroot environment and
          continue.</p>
        <dd>
      </dl>
      <p><a href="#lfsfaq">Back to the top.</a></p>

      <h3 id="packerrors">Package-specific errors</h3>
      <dl>
        <dt id="m4-mb-len-max-wrong">M4: Assumed value of MB_LEN_MAX wrong</dt>
        <dd>
          <p>This error message usually indicates that <code>limits.h</code>
          provided by GCC isn't including <code>limits.h</code> from Glibc
          as it should be.  There is one command as a workaround for
          <code>limits.h</code> in GCC Pass 1.  Do not forget to run the
          command.</p>
          <p>In LFS 10.0 through 11.3, there is another command as the
          workaround running <code>mkheaders</code> after installing Glibc
          (Chapter 5).  This command has been removed in LFS 12.0.  Either
          running this command building LFS 12.0 or later (likely because of
          a reuse of old scripts - note that such a reuse is strongly
          discouraged) or forgetting this command building LFS 10.0 through
          11.3 will also lead to this error message.</p>
          <p>If you've encountered this issue, untar the GCC tarball again
          and run the command at the bottom of GCC Pass 1 page to create
          <code>limits.h</code>.  Then if you are building LFS 12.0 or
          later, run <code>rm -f
          $LFS/tools/lib/gcc/$LFS_TGT/*/include-fixed/limits.h</code> which
          would fix the issue in case you've mistakenly run the
          <code>mkheaders</code> command which does not belong to the LFS
          version you are building.  If you are building LFS 11.0 through
          11.3, run the <code>mkheaders</code> command in Chapter 5
          Glibc.</p>
        </dd>

        <dt id="systemd-user-credentials-esrch">Systemd: systemd-networkd.service: Failed to determine user credentials: No such process</dt>
        <dd>
          <p>It's likely because <code>/etc/passwd</code> for sysv revision
          is misused in systemd-based system.  "No such process" is just the
          "standard" error message for <code>ESRCH</code>, it's not very
          helpful for diagnosis of this issue.</p>
        </dd>
      </dl>
      <p><a href="#lfsfaq">Back to the top.</a></p>

      <h3 id="confboot">Configuration and booting issues</h3>
      <dl>
        <dt id="unable-to-mount-root">Kernel panic - not syncing: VFS: Unable to mount root fs on ...</dt>
        <dd>
          <p>There are several reasons why the kernel might be unable to mount the root filesystem.</p>
          <ul>
            <li>Did you specify the correct partition in
            <code>/boot/grub/grub.cfg</code>?</li>
            <li>Is support for the hard drive enabled in the kernel. For SCSI
            this means support for the specific SCSI adapter.</li>
            <li>Is support for the hard drive compiled into the kernel, not
            just as a module. (Modules are stored on the filesystem. If a
            driver needed to access the filesystem is stored as a module on
            that filesystem, well ... you know ... ;)</li>
            <li>Is support for the filesystem compiled into the kernel. Again,
            not a module. Support for ext4 is enabled by default, but others
            like reiser, jfs, and xfs are not.</li>
          </ul>
        </dd>
        <dt id="respawning-too-fast">init: Id "1" respawning too fast: disabled for 5 minutes</dt>
        <dd>
          <p>When you see, in your syslogs, this line:</p>
          <code>init: Id "1" respawning too fast: disabled for 5 minutes</code>
          <p>It means you have an error in the /etc/inittab line beginning with the given id ("1" in this example).</p>
        </dd>
        <dt id="eth0-unknown-interface">eth0:unknown interface:No such device [failed] </dt>
        <dd>
          <p>The full error looks like this:</p>
          <div class="cmd">
            <p>eth0:unknown interface:No such device [failed]<br />
               Setting up default gateway...<br />
               SIOCADDRT:No such device [failed]</p>
          </div>
          <p>eth0 is a virtual device with no /dev entry. It refers to the
          first detected network card in your system. The reason the kernel
          can't find this device is because you forgot to add support for your
          network card in the kernel. The kernel detected the card but doesn't
          have a driver for it. The LFS boot script tries to bring up the
          network but fails because of this.</p>
          <p>Recompile your kernel with the proper driver, either built in or
          as a module. If you compiled the network driver as a module, then
          also adjust /etc/modules.conf to alias the network card module as
          eth0; for example: <code>alias eth0 8139too</code>. If you don't know
          which network card you have, you can use <code>dmesg</code>,
          /proc/pci or <code>lspci</code> to find out.</p>
          <p>And, udev may rename your network devices.  For example, eth0
          may be renamed to enp4s0.  You can run <code>ip link</code>
          command after booting the LFS system, and examine the output to
          know the name of your network devices.</p>
        </dd>
        <dt id="irq-nobody-cared">irq 9: nobody cared (try booting with the "irqpoll" option)</dt>
        <dd>
          <p>It may be a bug in the firmware (BIOS) or the drivers in
          kernel.  Some hardware vendors tend to use Windows-specific hacks
          in their BIOS, which is misinterpreted by Linux kernel and causing
          this kind of issue.</p>
          <p>If you see message like this but your system functions
          normally, you can ignore it.  If the system malfunctions, you can
          try the combinations of several kernel options to workaround:
          <code>irqpoll</code>, <code>noapic</code>, <code>pci=nocrs</code>,
          and <code>i8042.nopnp=1</code>.</p>
          <p>And, you can try <a href="https://wiki.archlinux.org/title/DSDT">ACPI DSDT override</a> if you
          really understand it.</p>
          <p>You can always report this kind of issue to
          <a href="https://bugzilla.kernel.org">Kernel bug tracker</a>,
          no matter if it's a BIOS bug.  The kernel developers want to make
          Linux runable even if the BIOS has this kind of bug.</p>
        </dd>
        <dt id="lfs-very-slow">LFS system is much slower than the host distro (or another distro)</dt>
        <dd>
          <p>If the LFS system is slower than another distro but not much
          slower, it's normal. We focus on building a Linux system from
          source code and we do nothing to tweak the system for marginal
          performance improvements.  The other distros may enable additional
          compiler optimizations, tune kernel options (via sysctl), or use
          other approaches to squeeze more performance out.  And, LFS uses
          a latest GCC release which is likely slower than an old GCC
          release.  A new GCC release often attempts to optimize the target
          code more heavily (these optimizations will slow down the
          compiliation, but hopefully make the compiled program faster).  So
          LFS will take more time building a large package (like Linux
          kernel).</p>
          <p>But, if the LFS system is <b>very</b> slow (for example, takes
          5 hours to build a kernel while the host distro needs only one
          hour to build the same kernel with exactly same configuration),
          it likely indicates a CPU dynamic frequency scaling issue.  You
          can monitor the value of "cpu MHz" in <code>/proc/cpuinfo</code>
          to see if your CPU is running at a reasonable frequency while a
          workload (like, building the kernel) is running on the CPU.</p>
          <p>If your CPU is running at a much lower frequency than expected
          (an Intel Core i3 building the kernel but running at only 800 MHz
          is definitely too slow), try to adjust the setting of "Default
          CPUFreq governor" in the kernel configuration and rebuild the
          kernel.  The ideal setting should limit the CPU at a low frequency
          when the system is idle, but boost it to the maximum performance
          while a workload is running.</p>
          <p>Note that a governor may behave differently on different CPUs. 
          For example, the "powersave" governor may work fine for one CPU
          model, but lock another CPU at 800 MHz no matter if there is a
          workload running.  If you can't (or don't want to spend too much
          time to) find an ideal setting, use the "performance" governor.</p>
          <p>On a modern Intel or AMD processor, the "energy performance
          preference" may also have a significant impact on the performance
          The default setting is usually "balance performance" which may
          severely throttle down the performance, especially when the CPU
          has many cores but only a few cores are utilized (for example,
          when measuring the SBU with <code>make -j1</code> on a
          Core i9-13900K). The easiest way to manange the energy performance
          preference is via power-profiles-daemon, read
          <a href='../blfs/view/svn/general/power-profiles-daemon.html'
             >power-profiles-daemon (SysV)</a> or
          <a href='../blfs/view/systemd/general/power-profiles-daemon.html'
             >power-profiles-daemon (Systemd)</a> for how to install and
          use it.  Alternatively you can try to change this setting via
          the BIOS if a configuration entry is provided.</p>
        </dd>
      </dl>

<!--#include virtual="/common/footer.html" -->
