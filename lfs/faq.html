<!--#set var="pageTitle" value="FAQ do LFS" -->
<!--#include virtual="header.html" -->
<!--#include virtual="menu.html" -->
    <div class="main">
      <h1>Perguntas Frequentes do LFS</h1>

      <p>O FAQ está dividido em três documentos. As <a href="/faq/index.html">Perguntas Frequentes gerais</a> 
      tem links para todas as perguntas e respostas. O <a href="/lfs/faq.html">FAQ do LFS</a> é uma seleção 
      de perguntas frequentes específicas do LFS e o <a href="/blfs/faq.html">FAQ do BLFS</a> é uma seleção 
      de perguntas frequentes específicas do BLFS.</p>

      <a id="lfsfaq"/>
      <h3><a href="#fre">Aprimoramentos solicitados frequentemente</a></h3>
      <ul>
        <li><a href="#why-not-faq">Por que não incluir o FAQ no livro?</a></li>
        <li><a href="#why-vim">Por que o vim está no livro?</a></li>
        <li><a href="#why-not-package-management">Por que não existe nenhum gerenciador de pacotes no livro?</a></li>
        <li><a href="#no-poweroff">Como faço minha máquina desligar no término das atividades?</a></li>
        <li><a href="#uefi">Como inicializo o LFS com UEFI?</a></li>
        <li><a href="#rebuild-ch8">Posso ignorar um pacote do Capítulo 8, vez que ele já foi construído no 
        Capítulo 6 ou 7 e está funcionando corretamente?</a></li>
        <li><a href="#get-rid-of-lib64">Posso modificar o código da GCC e me livrar do /lib64?</a></li>
      </ul>
      <h3><a href="#resources">Ao ler e construir o LFS</a></h3>
      <ul>
        <li><a href="#what-dist">Qual distribuição eu deveria usar para começar?</a></li>
        <li><a href="#kernel-modules">Como eu compilo um núcleo ou configuro módulos?</a></li>
        <li><a href="#gcc-warnings">Os avisos do compilador oriundos da GCC são ruins?</a></li>
        <li><a href="#dirty-sources">Preciso manter o fonte depois da instalação?</a></li>
        <li><a href="#procs-lfs">Existem informações acerca de como construir o LFS em outros processadores?</a></li>
        <li><a href="#cross-compile">Como eu compilo cruzadamente o LFS?</a></li>
        <li><a href="#dos-text">O que é um arquivo de texto no formato DOS?</a></li>
        <li><a href="#wget">Existe uma maneira de baixar todos os arquivos atuais de uma vez?</a></li>
      </ul>
      <h3><a href="#generrors">Erros gerais de compilação</a></h3>
      <ul>
        <li><a href="#optimizations">Quando usar sinalizadores de otimização (configurando a CFLAGS)</a></li>
	<li><a href="#configure-errors">A saída gerada do configure mostra erros; "gcc -V" não está errado?</a></li>
        <li><a href="#config-ice">Por que o GCC informa "Erro interno do compilador" para um programa "olá mundo"?</a></li>
        <li><a href="#dirty-sources">Eu não excluí a árvore do fonte depois da minha tentativa mais recente. Eu preciso?</a></li>
        <li><a href="#perm-denied">Eu estou obtendo `/dev/null: Permissão negada'</a></li>
        <li><a href="#sig11">sinal 11 (erro interno: Falha de segmentação)</a></li>
        <li><a href="#chroot-no-such-file">“Esse arquivo ou diretório não existe” tentando fazer chroot</a></li>
        <li><a href="#configure-no-such-file">bash: ./configure: Esse arquivo ou diretório não existe</a></li>
        <li><a href="#bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</a></li>
        <li><a href="#conf-guess-fail">configure não consegue adivinhar meu tipo de dispositivo.</a></li>
        <li><a href="#config-not-gnu-c">verificando se estamos usando GNU C... não</a></li>
        <li><a href="#no-ptys">O sistema não tem mais ptys. Peça para o(a) administrador(a) do sistema criar mais.</a></li>
        <li><a href="#config-status-0ax-y">./config.status: line 508: 0a1,66: comando não encontrado (ou 
        qualquer mensagem semelhante com apenas números diferentes)</a></li>
        <li><a href="#dev-null-as-cache">"configure: carregando cache /dev/null" em config.log</a></li>
      </ul>
      <h3><a href="#packerrors">Erros específicos de pacote</a></h3>
      <ul>
        <li><a href="#m4-mb-len-max-wrong">M4: Valor assumido de MB_LEN_MAX errado</a></li>
        <li><a href="#systemd-user-credentials-esrch">Systemd: systemd-networkd.service: Falha ao determinar 
        as credenciais de usuário(a): esse processo não existe</a></li>
      </ul>
      <h3><a href="#confboot">Problemas de configuração e inicialização</a></h3>
      <ul>
        <li><a href="#unable-to-mount-root">Pânico de núcleo - não sincronizando: VFS: Não é possível montar o root fs em ...</a></li>
        <li><a href="#respawning-too-fast">init: Id &quot;1&quot; regerando muito rápido: desativado por 5 minutos</a></li>
        <li><a href="#eth0-unknown-interface">eth0:interface desconhecida</a></li>
        <li><a href="#irq-nobody-cared">IRQ 9: ninguém se importou (tente inicializar com a opção "irqpoll")</a></li>
        <li><a href="#lfs-very-slow">O sistema LFS está muito mais lento que a distribuição anfitriã (ou outra distribuição)</a></li>
      </ul>
      <div class="newsItem"></div>

      <h3 id="fre">Aprimoramentos solicitados frequentemente</h3>
      <dl>
        <dt id="why-not-faq">Por que não incluir o FAQ no livro?</dt>
        <dd>

          <p>Marc Heerdink possivelmente tenha dito isso melhor em uma postagem na lfs-dev:</p>

          <blockquote><p>O problema é que o FAQ é um documento dinâmico. O FAQ para um lançamento de livro é 
          lançado somente depois da versão do livro em si, porque o FAQ é atualizado para refletir as 
          perguntas feitas acerca da versão atual do livro. Um link é melhor, pois você sempre terá as 
          respostas mais atualizadas à mão.</p></blockquote>

        </dd>
        <dt id="why-vim">Por que o vim está no livro?</dt>
        <dd>

          <p>Isso está bastante bem discutido no tópico que começa
<a href = "https://lists.linuxfromscratch.org/sympa/arc/lfs-dev/2002-02/msg00019.html">nesta postagem</a>.</p>

        </dd>
        <dt id="why-not-package-management">Por que não existe nenhum gerenciador de pacotes no livro?</dt>
        <dd>

          <p>O gerenciamento de pacotes – além daquele fornecido por tarballs e makefiles – está além do 
          escopo do livro. Se nada mais acontecer, o número de "soluções" diferentes deveria sugerir alguns 
          dos motivos.</p>

          <p>Aqui estão algumas das opções:</p>
          <ul>

            <li>Nenhum gerenciamento de pacotes é realmente necessário. A menos que seja desejável monitorar 
            minuciosamente o posicionamento do arquivo do pacote, qualquer pacote grande o suficiente para 
            garantir a remoção por motivos de espaço em disco pode ser instalado em /opt, conforme detalhado 
            pelo FHS (talvez em /opt/foo-x.x com um link a partir de /opt/foo), e novos lançamentos 
            geralmente podem ser instalados sobre as antigos, embora as principais atualizações e bibliotecas 
            geralmente sejam melhor feitas reconstruindo-se o sistema de baixo para cima.</li>

            <li>RPM, o Redhat Package Manager, é usado por diversas distribuições. Ele está disponível a 
            partir de <a href = "https://rpm.org/">https://rpm.org/</a> e existe uma
<a href = "../hints/downloads/files/">Dica do RPM</a> para ajudar com a instalação.</li>

            <li>Existem várias implementações de gerenciamento de pacotes no estilo de link simbólico:
            <ul>
              <li>Graft está disponível a partir de
<a href = "https://peters.gormand.com.au/Home/tools">https://peters.gormand.com.au/Home/tools</a>.</li>
              <li>GNU Stow está disponível a partir de
<a href = "https://www.gnu.org/software/stow/">https://www.gnu.org/software/stow/</a>.</li>
            </ul>
            </li>

            <li>O gerenciador de pacotes do NetBSD, pkgsrc, está disponível em outros sistemas, incluindo 
            Linux. Ele está em
<a href="ftp://ftp.netbsd.org/pub/pkgsrc/stable/">ftp://ftp.netbsd.org/pub/pkgsrc/stable/</a>.</li>

            <li>Originalmente baseado em um conjunto de comandos sequenciais escritos pelo próprio Gerard 
            Beekmans do LFS, install-log registra uma lista de arquivos instalados por um pacote à medida que 
            o pacote é instalado. Ele está disponível a partir de
<a href="https://install-log.sourceforge.net/">https://install-log.sourceforge.net/</a>.</li>

            <li>CheckInstall tenta registrar chamadas de sistema feitas por "make install". Ele está 
            disponível a partir de
<a href="https://asic-linux.com.mx/%7Eizto/checkinstall/">https://asic-linux.com.mx/~izto/checkinstall/</a>.</li>

            <li>pkgutils, usado pela distribuição CRUX, está disponível a partir de
<a href="https://crux.nu/Wiki/FaqPkgUtils">https://crux.nu/Wiki/FaqPkgUtils</a>.</li>

            <li>Existem algumas <a href="../hints/downloads/files/">dicas</a> disponíveis para gerenciadores 
            de pacotes.</li>

          </ul>

          <p>Se você tiver uma adição para a lista, por favor, envie uma mensagem eletrônica com o id dela, 
          URL e outras informações para o(a) mantenedor(a) do FAQ ou para uma lista de discussão apropriada 
          do LFS, de forma que ela possa ser adicionada aqui.</p>

        </dd>
        <dt id="no-poweroff">Como faço minha máquina desligar no término das atividades?</dt>
        <dd>

          <p>Gerenciamento de Eletricidade é uma função do núcleo; você precisa habilitá-lo no núcleo. No 
          núcleo 5.11, você tem de habilitar as opções para <code>ACPI (Advanced Configuration and Power 
          Interface</code> sob <code>Power managerment and ACPI options</code>. Para máquinas x86 de 32 bits 
          muito antigas, você provavelmente irá querer as opções de APM; máquinas mais novas geralmente 
          exigem ACPI. Certifique-se de que ou APM ou ACPI esteja habilitado no núcleo, mas, definitivamente 
          <strong>não</strong> ambos ao mesmo tempo - isso tem sido conhecido por causar problemas, tais como 
          nenhum dos dois realmente tendo efeito. Tente também desabilitar o SMP se você tiver somente um 
          processador; ele também impede um desligamento adequado. Certifique-se de ler a ajuda de cada 
          opção.</p>

          <p>Depois de reinicializar no novo núcleo, você deveria estar apto(a) a desligar tua máquina com o 
          comando <code>shutdown -h now</code> ou <code>poweroff</code> (leia-se também <code>man 
          shutdown</code> e <code>man halt</code>). Se você compilou APM ou ACPI como módulos, certifique-se 
          de que eles estejam carregados antes de tentar desligar. Algumas máquinas exigem que o APM ou ACPI 
          seja compilado no núcleo, porque ele [o APM ou o ACPI] precisa ser inicializado durante a 
          inicialização.</p>

        </dd>

        <dt id="uefi">Como inicializo o LFS com UEFI?</dt>
        <dd>

          <p>O GRUB pode ser construído para UEFI, mas fazer isso precisa de vários pacotes além do escopo do 
          LFS. Você pode consultar <a href="/blfs/view/svn/postlfs/grub-efi.html">a página do BLFS para 
          isso</a>.</p>

        </dd>

        <dt id="rebuild-ch8">Posso ignorar um pacote do Capítulo 8, vez que ele já foi construído no Capítulo 
        6 ou 7 e está funcionando corretamente?</dt>
        <dd>
          <p>Resposta curta: não.</p>
 
          <p>Resposta longa: queremos que o LFS seja "estabelecido": se algum pacote for reconstruído no 
          sistema LFS, o resultado (bibliotecas e binários) deveria ser o mesmo que o resultado no final do 
          livro do LFS. No Capítulo 6 as ferramentas são compiladas cruzadamente, onde muitos testes no 
          conjunto de comandos sequenciais <code>configure</code> não conseguem ser feitos. O resultado 
          "adivinhado" será usado, soluções alternativas desnecessárias serão habilitadas ou recursos 
          opcionais serão desabilitados. As ferramentas no Capítulo 7 são construídas para resolver 
          dependências circulares: muitos dos recursos opcionais delas dependem de pacotes ainda não 
          construídos e tem de ser desabilitados. Portanto, reconstruí-las no Capítulo 8 é necessário.</p>

          <p>Por outro lado, se você estiver construindo o Linux para alguma plataforma realmente pequena 
          onde você não consegue construir pacotes em um tempo razoável (por exemplo, um ARM de 16 MHz), você 
          pode compilar cruzadamente tudo no Capítulo 6, já que os Capítulos 7 e 8 não são aplicáveis. Ou 
          você pode fazer os Capítulos 7 e 8 com um emulador como o
<a href="/blfs/view/stable/postlfs/qemu.html">QEMU</a>.</p>

        </dd>
        <dt id="get-rid-of-lib64">Posso modificar o código da GCC e me livrar do /lib64?</dt>
        <dd>
          <p>Resposta curta: não.</p>
 
          <p>Resposta longa: o LSB impõe que o carregador de ELF esteja em /lib64/ld-linux-x86-64.so.2 no 
          x86-64.</p>

          <p>Resposta ainda mais longa: quando o núcleo é instruído a executar um executável ELF vinculado 
          dinamicamente, ele lê o caminho para o carregador de ELF rigidamente codificado no executável ELF, 
          que é /lib64/ld-linux-x86-64.so.2. Portanto, se não existir, o LFS não será capaz de executar 
          nenhum executável vinculado dinamicamente compilado em outro lugar. Por exemplo, executáveis 
          procedentes de pacotes de software comerciais (MATLAB ou COMSOL) ou binários baixados a partir da 
          página de lançamento do GitHub não executarão.</p>

        </dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="resources">Ao ler e construir o LFS</h3>
      <dl>
        <dt id="what-dist">Qual distribuição eu deveria usar para começar?</dt>
        <dd>

          <p>A maioria das distribuições relativamente recentes deveria servir. Você poderia consultar
<a href="/lfs/view/stable/chapter02/hostreqs.html">a página Requisitos do Sistema Anfitrião</a>.</p>

          <p>Certifique-se de ter instalado e (ou) atualizado os pacotes de desenvolvimento. (Procure aqueles 
          que começam com "gcc", "glibc" ou "libstdc++" ou terminam com "-dev" ou "-devel").</p>

          <p>Se você quiser usar o LFS como teu sistema principal e deseja instalá-lo sem primeiro instalar 
          uma distribuição, também é possível usar uma imagem ao vivo em DVD ou pendrive. Todas as principais 
          distribuições fornecem uma.</p>

        </dd>
        <dt id="kernel-modules">Como eu compilo um núcleo ou configuro módulos?</dt>
        <dd>

          <p>Em /usr/share/doc/linux-x.y.z ou onde quer que você desempacotou teu fonte do núcleo e a ajuda 
          na ferramenta de configuração do núcleo (make menuconfig), veja-se o Module-HOWTO em
<a href="https://www.tldp.org/HOWTO/Module-HOWTO/">https://www.tldp.org/HOWTO/Module-HOWTO/</a>.</p>

        </dd>
        <dt id="gcc-warnings">Os avisos do compilador oriundos da GCC são ruins?</dt>
        <dd>
          <p>Resposta curta: não.</p>

          <p>Resposta longa: provavelmente, mas somente para alguém que trabalha no pacote que você está 
          tentando compilar. Na maioria das vezes, tudo ficará bem, a menos que o make termine com um 
          erro.</p>

          <p>Aqui está um exemplo:</p>
          <div class="cmd">
            <p>sk ~/tmp $ cat &gt; Makefile<br />
               main:<br />
               gcc main.c<br />
               sk ~/tmp $ cat &gt; main.c<br />
               void main() { exit(0); }<br />
               sk ~/tmp $ make<br />
               gcc main.c<br />
               <strong>main.c: Na função `main':</strong><br />
               <strong>main.c:1: aviso: o tipo de retorno de `main' não é `int'</strong><br />
               sk ~/tmp $ ######## isso funcionou ########<br />
               sk ~/tmp $<br />
               sk ~/tmp $ cat &gt; main.c<br />
               int main() { e<span class="strong">xx</span>it(0) }<br />
               sk ~/tmp $ make<br />
               gcc main.c<br />
               <strong>main.c: Na função `main':</strong><br />
               <strong>main.c:1: erro de análise antes de `}'</strong><br />
               <strong>make: *** [main] Erro 1</strong><br />
               sk ~/tmp $ ######## isso falhou ########<br />
               sk ~/tmp $</p>
          </div>

          <p>Se você puder determinar que algum aviso indica um defeito real no software, informe o(a) 
          mantenedor(a) do mesmo.</p>

        </dd>

        <dt id="procs-lfs">Existem informações acerca de como construir o LFS em outros processadores?</dt>
        <dd>

          <p>Para informações acerca de como construir o LFS para uma ampla variedade de sistemas, dê uma 
          olhada na <a href="https://trac.clfs.org/wiki/read">ramificação Cross-LFS</a> do LFS.</p>

          <p>Para ARM, consulte a bifurcação do LFS para ARM (64 bits ou 32 bits) (
<a href='https://clfs.org/~kb0iic/lfs-sysv'>SysV</a> e
<a href='https://clfs.org/~kb0iic/lfs-systemd'>Systemd</a>), mantido por William Harrington; e outra 
          ramificação ARM64 do LFS (somente 64 bits,
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/arm64-systemd/'>Systemd</a> e
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/arm64/'>SysV [NÃO TESTADO!]</a>), mantida 
          por Xi Ruoyao.</p>

        </dd>
        <dt id="cross-compile">Como eu compilo cruzadamente o LFS?</dt>
        <dd>

          <p>Frequentemente é útil compilar o LFS para uma máquina em outra máquina. Digamos usar aquele 
          Athlon rápido de 1 Ghz para construir uma instalação para um 486 antigo. Embora isso tecnicamente 
          não seja compilação cruzada, os binários compilados para o Athlon não podem ser executados no 486 
          porque os binários compilados para o processador mais recente usam recursos que o processador mais 
          antigo não tem.</p>

          <p>O livro LFS especificamente para compilação cruzada é o livro
<a href="https://trac.clfs.org/wiki/read">Cross-LFS</a>. Outra fonte de informações seria a
<a href="/hints/downloads/files/">dica de compilação cruzada</a>.</p>

          <p>Os recursos fornecidos acima estão bastante desatualizados. Você pode modificar o processo de 
          construção do LFS depois do LFS 10.0 (desenvolvido por Pierre Labastie) para compilação cruzada do 
          LFS: configure <span>$LFS_TGT</span> para o trio de tua plataforma alvo e construa o conjunto de 
          ferramentas cruzadas no Capítulo 5 e ferramentas temporárias no Capítulo 6 normalmente. No final do 
          Capítulo 6, construa um núcleo e um carregador de inicialização para o alvo. Em seguida, copie o 
          sistema temporário para a plataforma alvo, inicialize-o e continue a construção a partir do 
          Capítulo 7. Leia-se a ramificação clfs-ng (
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/clfs-ng/'>SysV</a> e
<a href='https://www.linuxfromscratch.org/~xry111/lfs/view/clfs-ng-systemd/'>Systemd</a>) para 
          detalhes.</p>

        </dd>
        <dt id="dos-text">O que é um arquivo de texto no formato DOS?</dt>
        <dd>
          <p>Tem a ver com os caracteres usados ​​para finalizar as linhas.</p>
          <p>Existem dois que podem ser usados:</p>
          <ul>

            <li>Alimentação de linha: (LF) Octal:012 Decimal:10 Hexadecimal:0A Escape no estilo C:'\n' Desce 
            uma linha.</li>

            <li>Retorno de carro: (CR) Octal:015 Decimal:13 Hexadecimal:0D Escape no estilo C:'\r' Move para 
            a margem esquerda.</li>

          </ul>

          <p>Unix, DOS e MacOS usam, cada um, uma combinação diferente para finalizar linhas em arquivos de 
          texto:</p>

          <ul>

            <li>Unix: apenas LF. É por isso que, quando um arquivo de texto no formato Unix é enviado para 
            uma impressora raw, ela imprime<br />

                &nbsp;&nbsp;como<br />
                &nbsp;&nbsp;&nbsp;&nbsp;degraus de<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;escadas.<br /></li>

            <li>DOS: ambos, CRLF. É por isso que se você fizer "cat -v" em um arquivo DOS, verá um "^M" 
            (control m é retorno de carro) no final de cada linha. E é por isso que os conjuntos de comandos 
            sequenciais não funcionam quando escritos com o Bloco de Notas da Microsoft. O núcleo procura por 
            "/bin/sh^M" que não existe. Existe um "/bin/sh", mas nada com um "^M" anexado.</li>

            <li>MacOS clássico (antes do Mac OS X): somente CR. As impressoras provavelmente imprimem cada 
            linha acima da primeira, e as ferramentas Unix pensam que o arquivo inteiro é uma linha com "^M" 
            por toda parte. O Mac OS X segue a convenção Unix (somente LF).</li>

          </ul>
          <p>Para mudar de DOS para Unix, use</p>
          <div class="cmd">
            <p>cp &lt;idarquivo&gt; &lt;idarquivo&gt;.dos &amp;&amp;<br />
               cat &lt;idarquivo&gt;.dos | tr -d '\r' &gt; &lt;idarquivo&gt;</p>
          </div>

          <p>Ou no <code>vim</code>, você consegue converter um arquivo com <code>:set ff={unix, dos, 
          mac}</code>. Outras conversões provavelmente exigirão sed ou um uso diferente de tr e serão 
          deixadas como exercício para o(a) leitor(a).</p>

        </dd>
        <dt id="wget">Existe uma maneira de baixar todos os arquivos atuais de uma vez?</dt>
        <dd>

          <p>Sim. Você consegue baixar o arquivo LFS-BOOK-x.y-wget-list
<a href="https://www.linuxfromscratch.org/lfs/downloads/stable/wget-list">https://www.linuxfromscratch.org/lfs/downloads/stable/wget-list</a>. 
          Para baixar todos os arquivos, use a versão do <code>wget</code> na tua distribuição anfitriã para 
          executar:</p>

          <code>wget --input-file=LFS-BOOK-x.y-wget-list</code>

        </dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="generrors">Erros gerais de compilação</h3>
      <dl>
        <dt id="optimizations">Quando usar sinalizadores de otimização (configurando a CFLAGS)</dt>
        <dd>

          <p>Se você estiver recebendo erros e estiver configurando CFLAGS ou, do contrário, passando 
          sinalizadores de otimização para o compilador, esse possivelmente seja o problema.</p>

          <p>Se você perguntar na lista e eles(as) não conseguirem descobrir imediatamente, provavelmente 
          sugerirão tentar sem otimização. Portanto, se você apenas tentar novamente sem antes perguntar, 
          estará um passo à frente deles(as) :)</p>

          <p>Digno de observação é que a otimização de binutils, gcc ou glibc possivelmente faça com que 
          qualquer outro pacote falhe para compilar ou executar ou, do contrário, se comporte mal de maneiras 
          estranhas e misteriosas. Além disso, a otimização que funciona para outra pessoa possivelmente não 
          funcione para você. Sinalizadores que costumavam funcionar possivelmente parem de funcionar 
          misteriosamente. Mesmo algumas pequenas mudanças inocentes no hardware podem fazer a diferença.</p>

          <p>(Se você não sabe o que são sinalizadores de otimização, não se preocupe, você realmente não 
          precisa).</p>

        </dd>
	<dt id="configure-errors">A saída gerada do configure mostra erros; "gcc -V" não está errado?</dt>
        <dd>

	  <p>Para determinar o que está presente no sistema, os conjuntos de comandos sequenciais de 
	  configuração tentam vários comandos com várias opções de linha de comando. Eles então executam 
	  ações dependendo do código de saída dos comandos. Alguns desses comandos podem escrever mensagens 
	  de erro, e é isso que você vê, por exemplo, com "gcc -V". Mas o conjunto de comandos sequenciais de 
	  configuração em si não falhou.</p>

        </dd>
        <dt id="config-ice">Por que o GCC informa "Erro interno do compilador" para um programa "olá mundo"?</dt>
        <dd>
          <p>Você superotimizou o gcc.</p>
        </dd>
        <dt id="dirty-sources">Eu não excluí a árvore do fonte depois da minha tentativa mais recente. Eu preciso?</dt>
        <dd>

          <p>Sim. Em geral, <code>make clean</code> ou <code>make dist-clean</code> não são confiáveis ​​para 
          fontes limpos. Especialmente quando você hackeou manualmente os fontes ou aplicou remendos, você 
          deveria primeiro tentar novamente com um novo pacote desempacotado. A única exceção a essa regra é 
          o núcleo Linux, que exige que os fontes dele estejam presentes quando módulos de terceiros(as), 
          como os controladores NVidia, são necessários.</p>

        </dd>
        <dt id="perm-denied">Eu estou obtendo `/dev/null: Permissão negada'</dt>
        <dd>
          <p>/dev/null se parece com isto:</p>
          <div class="cmd">
            <p>$ ls -l /dev/null<br />
               crw-rw-rw- 1 root root 1, 3 Aug  3  2000 /dev/null</p>
          </div>

          <p>Se não, deveria. Consulte-se
<a href="#dev-null-as-cache">"configure: loading cache /dev/null" no config.log</a>.

          <p>Se parecer certo, o problema provavelmente está nas tuas opções de montagem. Veja-se a resposta 
          para
"<a href="#bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</a>", acima.</p>

        </dd>
        <dt id="sig11">sinal 11 (erro interno: Falha de segmentação)</dt>
        <dd>

          <p>A resposta longa está em
<a href="https://www.bitwizard.nl/sig11/">https://www.bitwizard.nl/sig11/</a>.</p>

          <p>A resposta curta é que se a reiniciação do make for um pouco mais longe a cada vez, você tem um 
          problema de hardware. (Se o make, ou o que quer que você esteja executando, falhar sempre no mesmo 
          lugar, então não é hardware).</p>

          <p>Primeiro, não faça overclock demais da CPU. Observe que, com uma CPU Intel "K" (desbloqueada), 
          mesmo a configuração padrão da placa-mãe geralmente já está em overclock, de forma que você 
          possivelmente precise até mesmo <b>retroceder</b> a partir do padrão, especialmente quando a CPU 
          está abaixo da média: a diferença individual entre todas as CPUs de um mesmo modelo pode ter um 
          efeito significativo na capacidade de overclock, portanto, comprar uma CPU desbloqueada é uma 
          espécie de jogo.</p>

          <p>Supondo que você não esteja fazendo overclock, o problema de hardware mais provável é memória 
          ruim, que você consegue verificar com Memtest86+ oriundo de
<a href="https://www.memtest.org/">https://www.memtest.org/</a>. <p>O superaquecimento da CPU é outro 
          problema comum de hardware. Certifique-se de que o cooler esteja instalado corretamente com pasta 
          térmica aplicada. E alguns coolers (especialmente coolers líquidos multifuncionais) não podem ser 
          configurados via BIOS e precisam de controlador de núcleo e (ou) software especial (por exemplo,
<a href='https://github.com/liquidctl/liquidctl'>liquidctl</a>) para configurar os parâmetros 
          corretamente. Se esse cooler não estiver configurado corretamente, ele poderá funcionar em uma 
          velocidade mais baixa (ou nem funcionar). Se o cooler já estiver funcionando em velocidade máxima, 
          mas a CPU ainda superaquecer, atualize o cooler ou faça downclock da CPU via BIOS.</p>

          <p>Se a memória ruim e o superaquecimento da CPU puderem ser descartados, veja-se a resposta 
          longa.</p>

        </dd>
        <dt id="chroot-no-such-file">“Esse arquivo ou diretório não existe” tentando fazer chroot</dt>
        <dd>
          <p>Exemplo desse erro é:</p>
          <div class="cmd">
            <p>/usr/bin/env: /bin/bash: No such file or directory</p>
          </div>

          <p>Se você tem certeza de que $LFS/bin/bash existe, o que acontece provavelmente é que o caminho 
          para o caminho do vinculador dinâmico incorporado no executável seja /lib64/ld-linux-x86-64.so.2 
          (/lib/ld-linux.so.2 para 32 bits), e quando alguém vai executar o binário dentro do chroot onde 
          /lib64/ld-linux-x86-64.so.2 ainda não existe, a mensagem de erro muito inútil
<code>No such file or directory</code> é exibida.</p>

          <p>Verifique se o link simbólico $LFS/lib64/ld-linux-x86-64.so.2 (deve ter como alvo 
          ../lib/ld-linux-x86-64.so.2 ou ../lib/ld-linux.so.2 para 32 bits) e (ou) $LFS/lib (deveria ter como 
          alvo usr/lib) estão quebrados. Observe que esses links simbólicos precisam ser relativos (ou seja, 
          deveriam ser ../lib/ld-linux-x86-64.so.2, <b>não</b> $LFS/lib/ld-linux-x86-64-so.2), de forma que 
          eles ainda sejam válidos no ambiente chroot.</p>

        </dd>
        <dt id="configure-no-such-file">bash: ./configure: Esse arquivo ou diretório não existe</dt>
        <dd>

          <p>Você se esqueceu de mudar de diretório (<code>cd</code>) para dentro do diretório extraído do 
          pacote depois de extraí-lo.</p>

        </dd>
        <dt id="bad-interpreter-permission-denied">./configure: mau intérprete: Permissão negada</dt>
        <dd>

          <p>Você provavelmente está recebendo isso enquanto constrói binutils no Capítulo 5 do Livro LFS. O 
          problema provavelmente está nas tuas opções de montagem. Você provavelmente tem uma linha no 
          /etc/fstab como:</p>

          <code>/dev/sda10  /mnt/lfs  ext2  user  1  2</code>

          <p>'user' é o sinalizador de montagem e é o problema. Para citar a página de manual do mount:</p>

          <cite>user: Permitir que um(a) usuário(a) comum monte o sistema de arquivos. Essa opção implica as 
          opções noexec, nosuid e nodev (a menos que substituídas por opções subsequentes, como na linha de 
          opções user,exec,dev,suid).</cite>

          <p>Portanto, mude a linha no /etc/fstab como isto:</p>

          <code>/dev/sda10  /mnt/lfs  ext2  defaults  1  2</code>

        </dd>
        <dt id="conf-guess-fail">configure não consegue adivinhar meu tipo de dispositivo.</dt>
        <dd>
          <p>Sintomas típicos se parecem com isto:</p>
          <div class="cmd">
            <p>sk ~/tmp-0.0 $ ./configure<br />
               creating cache ./config.cache<br />
               checking host system type...<br />
               <strong>configure: error: can not guess host type; you must specify one</strong><br />
               sk ~/tmp-0.0 $</p>
          </div>

          <p>O problema geralmente é que o conjunto de comandos sequenciais não consegue executar o 
          compilador. Geralmente é apenas um link simbólico /usr/bin/cc ausente. Você consegue consertar isso 
          assim:</p>

          <code>cd /usr/bin &amp;&amp; ln -s gcc cc</code>

          <p>Se isso não funcionar, verifique o arquivo config.log criado pelo configure. Os erros são 
          registrados lá e possivelmente indiquem o problema.</p>

        </dd>
        <dt id="config-not-gnu-c">verificando se estamos usando GNU C... não</dt>
        <dd>
          <p>Se você estiver recebendo um erro oriundo do configure como:</p>
          <div class="cmd">
            <p>verificando se estamos usando GNU C... não<br />
               configure: erro: GNU libc precisa ser compilada usando GNU CC</p>
          </div>

          <p>Pode ser porque o grep não está funcionando. Para testar se o grep está funcionando no ambiente 
          chroot, execute o seguinte comando a partir <em>de dentro</em> do chroot:</p>

          <code>grep -E root /etc/passwd</code>

          <p>Se não imprimir a linha do root a partir do /etc/passwd, novamente, você tem um problema. (Esse 
          teste também funciona se você encontrar o problema depois de reinicializar no novo sistema 
          LFS).</p>

        </dd>
        <dt id="no-ptys">O sistema não tem mais ptys. Peça para o(a) administrador(a) do sistema criar mais.</dt>
        <dd>

          <p>Se isso acontecer no ambiente chroot do LFS, certifique-se de que teu núcleo do anfitrião 
          suporta o pseudo terminal UNIX 98 (todas as distribuições de área de trabalho ou servidores não tão 
          antigas deveriam suportá-lo) e que os sistemas de arquivos virtuais do núcleo tenham sido montados 
          corretamente antes de entrar no ambiente chroot.</p>

          <p>Se isso acontecer no sistema completo construído seguindo a revisão SysV do livro LFS, é 
          provável que você tenha perdido a linha para o sistema de arquivos <code>devpts</code> no 
          <code>/etc/fstab</code>.

        </dd>
        <dt id="config-status-0ax-y">./config.status: line 508: 0a1,66: comando não encontrado (ou 
        qualquer mensagem semelhante com apenas números diferentes)<dt>
        <dd>

          <p>Verifique se <code>config.log</code> contém "configure: carregando cache /dev/null". Se for o 
          caso, consulte <a href='#dev-null-as-cache'>a entrada</a>.

        </dd>
        <dt id="dev-null-as-cache">"configure: carregando cache /dev/null" no config.log</dt>
        <dd>

          <p>Se isso acontecer no ambiente chroot do LFS, é provável que você tenha esquecido de montar 
          <code>/dev</code> vinculado ao <code>$LFS/dev</code> em "Preparando Sistemas de Arquivos Virtuais 
          do Núcleo".</p>

          <p>Saia do ambiente chroot primeiro. Em seguida, execute <code>ls -l /dev/null</code>. Isso deveria 
          gerar algo como <code>crw-rw-rw- 1 root root 1, 3 {alguma data} /dev/null</code>. Especialmente, a 
          primeira letra <code>c</code> e os números <code>1, 3</code> precisam estar corretos. Caso 
          contrário, significa que tua distribuição anfitriã está de alguma forma quebrada (isso 
          possivelmente aconteça se você usou o perigoso comando <code>rm -rf $LFS/*</code> ou similar quando 
          <code>/dev</code> foi montado vinculado). Para uma distribuição anfitriã moderna, isso pode ser 
          corrigido reinicializando-se (um <code>/dev</code> quebrado possivelmente impeça a reinicialização 
          normal e você possivelmente precise usar o botão reset). Para uma distribuição anfitriã muito 
          antiga, você possivelmente precise reinstalá-la (então por que não atualizar para uma moderna? 
          :)</p>

          <p>Agora sabemos que a distribuição anfitriã está sã. Certifique-se de que <code>$LFS</code> esteja 
          configurada corretamente e que a partição LFS seja montada primeiro. Use <code>umount -R 
          $LFS/dev</code> para desmontar <code>$LFS/dev</code> (caso você tenha montado algo errado lá) e, 
          então, remova tudo em <code>$LFS/dev</code> e siga a seção "Preparando Sistemas de Arquivos 
          Virtuais do Núcleo" para montar <code>$LFS/dev</code> e <code>$LFS/dev/pts</code> corretamente. 
          Depois que estiverem montados, você pode entrar novamente no ambiente chroot e continuar.</p>

        <dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="packerrors">Erros específicos de pacote</h3>
      <dl>
        <dt id="m4-mb-len-max-wrong">M4: Valor assumido de MB_LEN_MAX errado</dt>
        <dd>

          <p>Essa mensagem de erro geralmente indica que o <code>limits.h</code> fornecido pelo GCC não está 
          incluindo o <code>limits.h</code> oriundo da Glibc como deveria. Existe um comando como solução 
          alternativa para <code>limits.h</code> no GCC Passagem 1. Não se esqueça de executar o comando.</p>

          <p>No LFS 10.0 até 11.3, existe outro comando como solução alternativa executando-se 
          <code>mkheaders</code> depois de instalar a Glibc (Capítulo 5). Esse comando foi removido no LFS 
          12.0. Executar esse comando construindo o LFS 12.0 ou posterior (provavelmente por causa do reuso 
          de conjuntos de comandos sequenciais antigos - observe que tal reuso é fortemente desencorajado) ou 
          esquecer esse comando construindo o LFS 10.0 a 11.3 também levará a essa mensagem de erro.</p>

          <p>Se você tiver encontrado esse problema, desempacote o tarball do GCC novamente e execute o 
          comando na parte inferior da página GCC Passagem 1 para criar o <code>limits.h</code>. Então, se 
          você estiver construindo o LFS 12.0 ou posterior, execute <code>rm -f 
          $LFS/tools/lib/gcc/$LFS_TGT/*/include-fixed/limits.h</code> que corrigiria o problema caso você 
          tivesse erroneamente executado o comando <code>mkheaders</code> que não pertence à versão do LFS 
          que você está construindo. Se você estiver construindo o LFS 11.0 até 11.3, execute o comando 
          <code>mkheaders</code> na Glibc do Capítulo 5.</p>

        </dd>

        <dt id="systemd-user-credentials-esrch">Systemd: systemd-networkd.service: Falha ao determinar 
        as credenciais de usuário(a): esse processo não existe</dt>
        <dd>

          <p>Provavelmente é porque <code>/etc/passwd</code> para revisão sysv seja mal usado em sistemas 
          baseados em systemd. "Esse processo não existe" é apenas a mensagem de erro "padrão" para 
          <code>ESRCH</code>; ela não é muito útil para o diagnóstico desse problema.</p>

        </dd>
      </dl>
      <p><a href="#lfsfaq">Voltar para o topo.</a></p>

      <h3 id="confboot">Problemas de configuração e inicialização</h3>
      <dl>
        <dt id="unable-to-mount-root">Pânico de núcleo - não sincronizando: VFS: Não é possível montar o root fs em ...</dt>
        <dd>
          <p>Existem várias razões pelas quais o núcleo estaria inapto para montar o sistema de arquivos raiz.</p>
          <ul>

            <li>Você especificou a partição correta em <code>/boot/grub/grub.cfg</code>?</li>

            <li>O suporte para a unidade rígida está habilitado no núcleo? Para SCSI isso significa suporte 
            para o adaptador específico SCSI.</li>

            <li>O suporte para a unidade rígida está compilado internamente no núcleo, não apenas como um 
            módulo? (Os módulos são armazenados no sistema de arquivos. Se um controlador necessário para 
            acessar o sistema de arquivos for armazenado como um módulo nesse sistema de arquivos, bem... 
            você sabe... ;)</li>

            <li>O suporte para o sistema de arquivos está compilado internamente no núcleo? Novamente, não um 
            módulo? O suporte para ext4 está habilitado por padrão, mas outros, como reiser, jfs e xfs, não 
            estão.</li>

          </ul>
        </dd>
        <dt id="respawning-too-fast">init: Id &quot;1&quot; regerando muito rápido: desativado por 5 minutos</dt>
        <dd>
          <p>Quando você vir, em teus registros do sistema, esta linha:</p>
          <code>init: Id "1" respawning too fast: disabled for 5 minutes</code>
          <p>Isso significa que você tem um erro na linha do /etc/inittab que começa com o id fornecido ("1" nesse exemplo).</p>
        </dd>
        <dt id="eth0-unknown-interface">eth0:interface desconhecida:Não existe tal dispositivo [falhou]</dt>
        <dd>
          <p>O erro completo se parece com isto:</p>
          <div class="cmd">
            <p>eth0:unknown interface:No such device [failed]<br />
               Setting up default gateway...<br />
               SIOCADDRT:No such device [failed]</p>
          </div>

          <p>eth0 é um dispositivo virtual sem entrada de /dev. Refere-se à primeira placa de rede de 
          intercomunicação detectada em teu sistema. A razão pela qual o núcleo não consegue encontrar esse 
          dispositivo é porque você se esqueceu de adicionar suporte para tua placa de rede de 
          intercomunicação no núcleo. O núcleo detectou a placa, mas não tem um controlador para ela. O 
          conjunto de comandos sequenciais de inicialização do LFS tenta ativar a rede de intercomunicação, 
          mas falha por causa disso.</p>

          <p>Recompile teu núcleo com o controlador apropriado, integrado ou como um módulo. Se você compilou 
          o controlador de rede de intercomunicação como um módulo, então ajuste também o /etc/modules.conf 
          para apelidar o módulo da placa de rede de intercomunicação como eth0; por exemplo: <code>alias 
          eth0 8139too</code>. Se não souber qual placa de rede de intercomunicação tem, você pode usar 
          <code>dmesg</code>, /proc/pci ou <code>lspci</code> para descobrir.</p>

          <p>E o udev possivelmente renomeie teus dispositivos de rede de intercomunicação. Por exemplo, eth0 
          possivelmente seja renomeado para enp4s0. Você pode executar o comando <code>ip link</code> depois 
          de inicializar o sistema LFS e examinar a saída gerada para saber o nome dos teus dispositivos de 
          rede de intercomunicação.</p>

        </dd>
        <dt id="irq-nobody-cared">IRQ 9: ninguém se importou (tente inicializar com a opção "irqpoll")</dt>
        <dd>

          <p>Possivelmente seja um defeito no firmware (BIOS) ou nos controladores no núcleo. Alguns(as) 
          fornecedores(as) de hardware tendem a usar hacks específicos do Windows no BIOS deles(as), o que é 
          mal interpretado pelo núcleo Linux e causa esse tipo de problema.</p>

          <p>Se você vir uma mensagem como essa, mas teu sistema funcionar normalmente, você pode ignorá-la. 
          Se o sistema funcionar erradamente, você pode tentar as combinações de várias opções do núcleo para 
          contornar: <code>irqpoll</code>, <code>noapic</code>, <code>pci=nocrs</code> e 
          <code>i8042.nopnp=1</code>.</p>

          <p>E, pode tentar <a href="https://wiki.archlinux.org/title/DSDT">substituição DSDT da ACPI</a> se 
          você realmente entendê-la.</p>

          <p>Você sempre pode informar esse tipo de problema para
<a href="https://bugzilla.kernel.org">rastreador de defeitos do Núcleo</a>, não importa se for um 
          defeito de BIOS. Os(As) desenvolvedores(as) do núcleo querem tornar o Linux executável mesmo que o 
          BIOS tenha esse tipo de defeito.</p>

        </dd>
        <dt id="lfs-very-slow">O sistema LFS está muito mais lento que a distribuição anfitriã (ou outra distribuição)</dt>
        <dd>

          <p>Se o sistema LFS estiver mais lento que outra distribuição, mas não muito mais lento, é normal. 
          Nós focamos em construir um sistema Linux a partir do código-fonte e não fazemos nada para ajustar 
          o sistema para melhorias marginais de desempenho. As outras distribuições possivelmente habilitem 
          otimizações adicionais do compilador, ajustem opções do núcleo (via sysctl) ou usem outras 
          abordagens para extrair mais desempenho. E o LFS usa um lançamento mais recente do GCC, que 
          provavelmente é mais lento que um lançamento antigo do GCC. Um novo lançamento do GCC 
          frequentemente tenta otimizar o código-alvo mais intensamente (essas otimizações desacelerarão a 
          compilação, mas esperançosamente tornarão o programa compilado mais rápido). Portanto, o LFS levará 
          mais tempo construindo um pacote grande (como o núcleo Linux).</p>

          <p>Mas, se o sistema LFS estiver <b>muito</b> lento (por exemplo, levar 5 horas para construir um 
          núcleo, enquanto a distribuição anfitriã precisa de somente uma hora para construir o mesmo núcleo 
          com exatamente a mesma configuração), isso provavelmente indica um problema de escala de frequência 
          dinâmica da CPU. Você consegue monitorar o valor de "cpu MHz" em <code>/proc/cpuinfo</code> para 
          ver se tua CPU está executando em uma frequência razoável enquanto uma carga de trabalho (como 
          construir o núcleo) está executando na CPU.</p>

          <p>Se tua CPU estiver executando em uma frequência muito menor que a esperada (um Intel Core i3 
          construindo o núcleo, mas executando a somente 800 MHz é definitivamente lento demais), tente 
          ajustar a configuração de "Default CPUFreq governor" na configuração do núcleo e reconstrua o 
          núcleo. A configuração ideal deveria limitar a CPU a uma frequência baixa quando o sistema estiver 
          ocioso, mas aumentá-la para o desempenho máximo enquanto uma carga de trabalho estiver 
          executando.</p>

          <p>Observe que um regulador possivelmente se comporte diferentemente em CPUs diferentes. Por 
          exemplo, o regulador "powersave" possivelmente funcione bem para um modelo de CPU, mas trave outra 
          CPU em 800 MHz, não importando se existe uma carga de trabalho executando. Se você não conseguir 
          (ou não quiser gastar muito tempo para) encontrar uma configuração ideal, use o regulador 
          "performance".</p>

          <p>Em um processador moderno Intel ou AMD, a "preferência de desempenho elétrico" também pode ter 
          um impacto significativo no desempenho. A configuração padrão geralmente é "desempenho de 
          equilíbrio", o que pode reduzir severamente o desempenho, especialmente quando a CPU tem muitos 
          elementos de processamento, mas somente uns poucos elementos de processamento são utilizados (por 
          exemplo, ao medir a UPC com <code>make -j1</code> em um Core i9-13900K). A maneira mais fácil de 
          gerenciar a preferência de desempenho elétrico é por meio do power-profiles-daemon, leia-se
<a href='../blfs/view/svn/general/power-profiles-daemon.html'>power-profiles-daemon (SysV)</a> ou
<a href='../blfs/view/systemd/general/power-profiles-daemon.html'>power-profiles-daemon (Systemd)</a> 
          para como instalá-lo e usá-lo. Alternativamente, você pode tentar mudar essa configuração por meio 
          do BIOS se uma entrada de configuração for fornecida.</p>

        </dd>
      </dl>

<!--#include virtual="/common/footer.html" -->
